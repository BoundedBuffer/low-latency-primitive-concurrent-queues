{"name":"Bounded Buffer","tagline":"Low latency, lock free, primitive bounded blocking queues. They are extremely quick as they use the faster CPU store-store barrier, they also mimic the interface of BlockingQueue, but take primitives to reduce auto boxing in your code and hence your GC overhead.","body":"### Aim\r\n\r\nOur aim is to be extremely low latency with near zero [GC](http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html) overhead.\r\n\r\n\r\nAn example of how to use on of our low latency bounded queues.\r\n\r\n```\r\n\r\n// writer thread\r\nExecutors.newSingleThreadExecutor().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        queue.add(1);\r\n    }\r\n});\r\n\r\n// reader thread\r\nExecutors.newSingleThreadExecutor().execute(new Runnable() {\r\n    @Override\r\n    public void run() {\r\n        final int value = queue.take();\r\n    }\r\n});\r\n\r\n\r\nPerformance comparison\r\n\r\n![PerformanceComparison](https://raw.github.com/BoundedBuffer/low-latency-primitive-concurrent-queues/master/src/test/resources/performance-comparison.png)\r\n\r\n\r\n```\r\n\r\n### Maven Central\r\nWe are hosted at [Maven Central] (http://search.maven.org), one of the quickest ways to get up and running is to add this [Maven](http://maven.apache.org/what-is-maven.html) dependency to your pom file :\r\n\r\n```\r\n<dependency>\r\n    <groupId>uk.co.boundedbuffer</groupId>\r\n    <artifactId>low-latency-primitive-concurrent-queues</artifactId>\r\n    <version>1.0.0</version>\r\n<dependency>\r\n```\r\n\r\n### JavaDoc\r\nHaving trouble ? Check out our documentation at [JavaDoc] (http://boundedbuffer.github.io/low-latency-primitive-concurrent-queues/apidocs/)\r\n\r\n### Is this Queue Thread Safe ?\r\n\r\nYes - it's thread safe, but you are limited to using just two threads per queue instance, One producer thread and a consumer thread.\r\n\r\n### Why am I limited to only using just two threads ?\r\n\r\nThe queues take advantage of the Unsafe.putOrderedX(), which provides of non-blocking code with guaranteed writes.\r\nThese writes will not be re-ordered by instruction reordering, they use a faster store-store barrier, rather than the the slower store-load barrie ( which is used when doing a volatile write ). One of the trade offs with this improved performance is the visibility of the reads and writes between cores.\r\n\r\n### Licence\r\n[Apache v2](http://www.apache.org/licenses/LICENSE-2.0.html)\r\n\r\n### Contributors\r\nContributors are extremely welcome, just fork this project, make your changes, and we'd be happy to review your pull-request.\r\n\r\n### Support or Contact\r\nHaving Problems ? Contact support@boundedbuffer.com and weâ€™ll help you sort it out.\r\n\r\n### Blog\r\nIf you are interest in low latency java, see my blog at [http://robsjava.blogspot.co.uk] (http://robsjava.blogspot.co.uk)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}