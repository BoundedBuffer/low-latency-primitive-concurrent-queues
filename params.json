{"name":"Low Latency Primitive Concurrent Queues","tagline":"A low latency, lock free, primitive bounded blocking queue backed by an int[]. This class mimics the interface of BlockingQueue, however works with primitive ints rather than Objects, so is unable to actually implement the BlockingQueue.  Takes advantage of the Unsafe.putOrderedObject, which allows us to create non-blocking code with guaranteed writes. These writes will not be re-orderd by instruction reordering. Under the covers it uses the faster store-store barrier, rather than the the slower store-load barrier, which is used when doing a volatile write. One of the trade off with this improved performance is we are limited to a single producer, single consumer. ","body":"### Performance.\r\n\r\n```\r\nPerforming 64 loops, arrayBlockingQueueReadAndWrites() took 1417.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 1189.000 us on average, ratio=1.2\r\nPerforming 512 loops, arrayBlockingQueueReadAndWrites() took 3144.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 572.000 us on average, ratio=5.5\r\nPerforming 4,096 loops, arrayBlockingQueueReadAndWrites() took 20865.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 2253.000 us on average, ratio=9.3\r\nPerforming 32,768 loops, arrayBlockingQueueReadAndWrites() took 25420.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 5194.000 us on average, ratio=4.9\r\nPerforming 262,144 loops, arrayBlockingQueueReadAndWrites() took 67244.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 22665.000 us on average, ratio=3.0\r\nPerforming 2,097,152 loops, arrayBlockingQueueReadAndWrites() took 630941.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 183390.000 us on average, ratio=3.4\r\nPerforming 16,777,216 loops, arrayBlockingQueueReadAndWrites() took 4770970.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 1469012.000 us on average, ratio=3.2\r\nPerforming 134,217,728 loops, arrayBlockingQueueReadAndWrites() took 38805398.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 8564390.000 us on average, ratio=4.5\r\nPerforming 1,073,741,824 loops, arrayBlockingQueueReadAndWrites() took 289992734.000 us and using lazyConcurrentBlockingIntQueueReadsAndWrites took 66038796.000 us on average, ratio=4.4\r\n```\r\n\r\n\r\n### Designer Templates\r\nWe've crafted some handsome templates for you to use. Go ahead and continue to layouts to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved if it remained markdown format.\r\n\r\n### Rather Drive Stick?\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator written by our own Tom Preston-Werner. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor's GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out the documentation at http://help.github.com/pages or contact support@github.com and weâ€™ll help you sort it out.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}